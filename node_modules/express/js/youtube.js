


// 2. This code loads the IFrame Player API code asynchronously.
var tag = document.createElement('script');

tag.src = "https://www.youtube.com/iframe_api";
var firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

// 3. This function creates an <iframe> (and YouTube player)
//    after the API code downloads.
var currindex;
var curr;
var prev;
var next;
var temp;
var currdisp = "#curr";
var nextdisp = "#next";
var prevdisp = "#prev";

var initialized = false;
function initIFrames(){
  currindex = 0;
  loadTitle();
  animateTitle();
  curr = new YT.Player('curr', {
    height: '390',
    width: '640',
    videoId: queue[0][0],
    playerVars: {
      'autoplay': 1,
      'showinfo': 0,
      'controls': 0,
      'iv_load_policy': 3,
      'disablekb': 1
    },
    events: {
      'onReady': onPlayerReady,
      'onError': onPlayerError,
      'onStateChange': onPlayerStateChange
    }
  });

  prev = new YT.Player('prev', {
    height: '390',
    width: '640',
    videoId: queue[0][0],
    playerVars: {
      'autoplay': 1,
      'showinfo': 0,
      'controls': 0,
      'iv_load_policy': 3,
      'disablekb': 1
    },
    events: {
      'onReady': onPlayerReady,
      'onError': onPlayerError,
      'onStateChange': onPlayerStateChange
    }
  });

  next = new YT.Player('next', {
    height: '390',
    width: '640',
    videoId: queue[1][0],
    playerVars: {
      'autoplay': 1,
      'showinfo': 0,
      'controls': 0,
      'iv_load_policy': 3,
      'disablekb': 1
    },
    events: {
      'onReady': onPlayerReady,
      'onError': onPlayerError,
      'onStateChange': onPlayerStateChange
    }
  });

  initialized = true;
}

function onYouTubeIframeAPIReady() {
  loadVideos().always(function() { //is returned as deffered object
    try {
      initIFrames();
    }catch(err) {
      alert(err.message);
    }
  });
}

// 4. The API will call this function when the video player is ready.
function onPlayerReady(event) {
  if(!initialized || curr===undefined) return;
  playYTVideo(event.target);
}


function onPlayerError(event) {
  if(!initialized || curr===undefined) return;
  if(event.target == curr){
    queue.splice(currindex,1);
    loadYTVideo(curr, queue[currindex][0]);
    loadYTVideo(next, queue[currindex+1][0]);

  }
  if(event.target == next){
    queue.splice(currindex+1,1);
    loadYTVideo(next, queue[currindex+1][0]);
  }
}
// 5. The API calls this function when the player's state changes.
//    The function indicates that when playing a video (state=1),
//    the player should play for six seconds and then stop.
var done = false;
function onPlayerStateChange(event) {
  if(!initialized || curr===undefined) return;
  if(event.data == YT.PlayerState.UNSTARTED){
    playYTVideo(event.target);
  }
  if (event.data == YT.PlayerState.PLAYING) {
    pauseYTVideo(prev);
    pauseYTVideo(next);
  }
  if (event.data == YT.PlayerState.ENDED)
    nextVideo();
}
function stopVideo() {
  player.stopVideo();
}

function nextVideo() {
  if(!initialized || curr===undefined) return;
  if(currindex == queue.length-1){
    currindex = 0;
    loadYTVideo(curr, queue[currindex][0]);
    loadYTVideo(next, queue[currindex+1][0]);
    return;
  }
  pauseYTVideo(curr);

  temp = prev;
  prev = curr;
  curr = next;
  next = temp;
  
  playYTVideo(curr);

  currindex++;
  if( currindex < queue.length - 1)
    loadYTVideo(next, queue[currindex+1][0]);

  seekYT(prev, 0);
  seekYT(next, 0);

  temp = prevdisp;
  prevdisp = currdisp;
  currdisp = nextdisp;
  nextdisp = temp;
  $( currdisp ).css( "display", "block" );
  $( nextdisp ).css( "display", "none" );
  $( prevdisp ).css( "display", "none" );

  if(currindex > queue.length - 15)
    loadVideos();

  loadTitle();
  animateTimeBar();
}

function previousVideo() {
  if(!initialized || curr===undefined) return;
  if (currindex == 0) return;
  pauseYTVideo(curr);

  temp = next;
  next = curr;
  curr = prev;
  prev = temp;

  playYTVideo(curr);

  currindex--;
  if( currindex > 0)
    loadYTVideo(prev, queue[currindex-1][0]);

  seekYT(prev,0);
  seekYT(next, 0);

  temp = nextdisp;
  nextdisp = currdisp;
  currdisp = prevdisp;
  prevdisp = temp;

  $( currdisp ).css( "display", "block" );
  $( nextdisp ).css( "display", "none" );
  $( prevdisp ).css( "display", "none" );

  loadTitle();
  animateTimeBar();
}




function togglePlayPause(){
  if(curr===undefined || !initialized) return;
  if(getYTPlayerState(curr)==2)
    playYTVideo(curr);
  else
    pauseYTVideo(curr);
}

function pauseVideo(){
  if(!initialized || curr===undefined) return;
  pauseYTVideo(curr);
}


function getVideoProgress(){
  if(!initialized || curr===undefined || curr===null) return 0;
  var totaltime = curr.getDuration();
  var nowtime = curr.getCurrentTime();
  return totaltime > 0 ? 100 * nowtime / totaltime : 0;
}

function skipVideoTo(index){
  if(!initialized || curr===undefined) return 0;
  var totaltime = curr.getDuration();
  var nowtime = curr.getCurrentTime();
  if(index == -1){    //rewind
    index = Math.round(10*nowtime/totaltime) - 1;
  }
  if(index == -2){    //fastforward
    index = Math.round(10*nowtime/totaltime) + 1;
  }
  if(index == -1){
    if(currindex == 0){
      seekYT(curr,0);
    }
    previousVideo();
    animateTitle();
    return;
  }
  if(index == 10){
    nextVideo();
    animateTitle();
    return;
  }
  seekYT(curr,index * totaltime / 10);
}

function pauseYTVideo(ytplayer){
  try{
    ytplayer.pauseVideo();
  }catch (err){
    YTError(ytplayer);
  }
}

function playYTVideo(ytplayer){
  try{
    ytplayer.playVideo();
  }catch (err){
    YTError(ytplayer);
  }
}

function getYTPlayerState(ytplayer){
  try{
    return ytplayer.getPlayerState();
  }catch (err){
    YTError(ytplayer);
    return -1;
  }
}


function loadYTVideo(ytplayer, videoId){
  try{
    ytplayer.loadVideoById({'videoId': videoId, 'startSeconds': 0, 'suggestedQuality': 'large'});
  }catch (err){
    YTError(ytplayer);
  }
}

function seekYT(ytplayer, position){
  try{
    ytplayer.seekTo(position);
  }catch (err){
    YTError(ytplayer);
  }
}

function YTError(ytplayer){
  var newYTPlayer = new YT.Player('curr2', {
    height: '390',
    width: '640',
    videoId: queue[1][0],
    playerVars: {
      'autoplay': 1,
      'showinfo': 0,
      'controls': 0,
      'iv_load_policy': 3,
      'disablekb': 1
    },
    events: {
      'onReady': onPlayerReady,
      'onError': onPlayerError,
      'onStateChange': onPlayerStateChange
    }
  });

  if(ytplayer == curr){
    alert('error curr');
    curr = newYTPlayer;
  }
  if(ytplayer == next){
    alert('error next');
    next = newYTPlayer;
  }
  if(ytplayer == prev){
    alert('error prev');
    prev = newYTPlayer;
  }
}
